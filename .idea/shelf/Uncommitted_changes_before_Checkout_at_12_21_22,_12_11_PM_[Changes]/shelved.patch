Index: src/main/GameState.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main;\n\nimport main.moveEval.Psqt;\nimport main.moveGen.MoveGen;\nimport main.moveGen.Vector;\nimport main.types.*;\nimport main.utils.Score;\nimport main.utils.Utils;\n\nimport java.util.*;\n\nfinal public class GameState {\n    private GameState() {\n    }\n\n    public static void main(String[] args) {\n        loadFen(args[1]);\n        System.out.println(countNumOfPositions(Integer.parseInt(args[0]), true));\n    }\n\n    public static int[] board = new int[128];\n    //start index for each piece is equal to Piece.id - 1 * 10 (need to multiply by 10 bc that is max amount of possible\n    // pieces\n    // need to subtract 1 from Piece.id bc Piece enum starts with NULL\n    public static Phase phase = Phase.MG;\n    public static Map<Color, Square[]> pieceList = new HashMap<>();\n    public static Map<Color, Integer> pawnCount = new HashMap<>();\n    public static Map<Color, Integer> pieceCount = new HashMap<>();\n    public static Map<Color, Integer> pieceBonus = new HashMap<>();\n    public static long zobristHash;\n    public static Map<Long, Integer> totalRepititions = new HashMap<>();\n\n    public static Color activeColor = Color.W;\n    public static Square enPassant = Square.NULL;\n    public static int halfmoves;\n    public static int castleRights =\n            Castle.W_K.value | Castle.W_Q.value | Castle.B_k.value | Castle.B_q.value;\n\n    // init board + pieceList + get zobrish hash\n    static {\n        pieceList.put(Color.W,\n                new Square[51]);\n        pieceList.put(Color.B,\n                new Square[51]);\n        pawnCount.put(Color.W, 0);\n        pawnCount.put(Color.B, 0);\n        pieceCount.put(Color.W, 0);\n        pieceCount.put(Color.B, 0);\n\n        board[0] = Color.W.id | Piece.ROOK.id;\n        board[1] = Color.W.id | Piece.KNIGHT.id;\n        board[2] = Color.W.id | Piece.BISHOP.id;\n        board[3] = Color.W.id | Piece.QUEEN.id;\n        board[4] = Color.W.id | Piece.KING.id;\n        board[5] = Color.W.id | Piece.BISHOP.id;\n        board[6] = Color.W.id | Piece.KNIGHT.id;\n        board[7] = Color.W.id | Piece.ROOK.id;\n        board[16] = Color.W.id | Piece.PAWN.id;\n        board[17] = Color.W.id | Piece.PAWN.id;\n        board[18] = Color.W.id | Piece.PAWN.id;\n        board[19] = Color.W.id | Piece.PAWN.id;\n        board[20] = Color.W.id | Piece.PAWN.id;\n        board[21] = Color.W.id | Piece.PAWN.id;\n        board[22] = Color.W.id | Piece.PAWN.id;\n        board[23] = Color.W.id | Piece.PAWN.id;\n\n        final Square[] wPieceList = pieceList.get(Color.W);\n        Arrays.fill(wPieceList,\n                Square.NULL);\n        putPiece(Color.W, Piece.PAWN, Square.A2, false);\n        putPiece(Color.W, Piece.PAWN, Square.B2, false);\n        putPiece(Color.W, Piece.PAWN, Square.C2, false);\n        putPiece(Color.W, Piece.PAWN, Square.D2, false);\n        putPiece(Color.W, Piece.PAWN, Square.E2, false);\n        putPiece(Color.W, Piece.PAWN, Square.F2, false);\n        putPiece(Color.W, Piece.PAWN, Square.G2, false);\n        putPiece(Color.W, Piece.PAWN, Square.H2, false);\n        putPiece(Color.W, Piece.ROOK, Square.A1, false);\n        putPiece(Color.W, Piece.KNIGHT, Square.B1, false);\n        putPiece(Color.W, Piece.BISHOP, Square.C1, false);\n        putPiece(Color.W, Piece.QUEEN, Square.D1, false);\n        putPiece(Color.W, Piece.KING, Square.E1, false);\n        putPiece(Color.W, Piece.BISHOP, Square.F1, false);\n        putPiece(Color.W, Piece.KNIGHT, Square.G1, false);\n        putPiece(Color.W, Piece.ROOK, Square.H1, false);\n\n        board[112] = Color.B.id | Piece.ROOK.id;\n        board[113] = Color.B.id | Piece.KNIGHT.id;\n        board[114] = Color.B.id | Piece.BISHOP.id;\n        board[115] = Color.B.id | Piece.QUEEN.id;\n        board[116] = Color.B.id | Piece.KING.id;\n        board[117] = Color.B.id | Piece.BISHOP.id;\n        board[118] = Color.B.id | Piece.KNIGHT.id;\n        board[119] = Color.B.id | Piece.ROOK.id;\n        board[96] = Color.B.id | Piece.PAWN.id;\n        board[97] = Color.B.id | Piece.PAWN.id;\n        board[98] = Color.B.id | Piece.PAWN.id;\n        board[99] = Color.B.id | Piece.PAWN.id;\n        board[100] = Color.B.id | Piece.PAWN.id;\n        board[101] = Color.B.id | Piece.PAWN.id;\n        board[102] = Color.B.id | Piece.PAWN.id;\n        board[103] = Color.B.id | Piece.PAWN.id;\n\n        final Square[] bPieceList = pieceList.get(Color.B);\n        Arrays.fill(bPieceList,\n                Square.NULL);\n        putPiece(Color.B, Piece.PAWN, Square.A7, false);\n        putPiece(Color.B, Piece.PAWN, Square.B7, false);\n        putPiece(Color.B, Piece.PAWN, Square.C7, false);\n        putPiece(Color.B, Piece.PAWN, Square.D7, false);\n        putPiece(Color.B, Piece.PAWN, Square.E7, false);\n        putPiece(Color.B, Piece.PAWN, Square.F7, false);\n        putPiece(Color.B, Piece.PAWN, Square.G7, false);\n        putPiece(Color.B, Piece.PAWN, Square.H7, false);\n        putPiece(Color.B, Piece.ROOK, Square.A8, false);\n        putPiece(Color.B, Piece.KNIGHT, Square.B8, false);\n        putPiece(Color.B, Piece.BISHOP, Square.C8, false);\n        putPiece(Color.B, Piece.QUEEN, Square.D8, false);\n        putPiece(Color.B, Piece.KING, Square.E8, false);\n        putPiece(Color.B, Piece.BISHOP, Square.F8, false);\n        putPiece(Color.B, Piece.KNIGHT, Square.G8, false);\n        putPiece(Color.B, Piece.ROOK, Square.H8, false);\n\n        zobristHash = ZobristKey.hash();\n    }\n\n    public static void printBoard() {\n        System.out.println();\n        Map<Color, String[]> unicode_pieces = new HashMap<>();\n\n        unicode_pieces.put(Color.W, new String[]{\".\", \"♟︎\", \"♞\", \"♝\", \"♜\", \"♛\", \"♚\"});\n        unicode_pieces.put(Color.B, new String[]{\".\", \"♙\", \"♘\", \"♗\", \"♖\", \"♕\", \"♔\"})\n        ;\n        for (int rank = 7; rank >= 0; rank--) {\n            for (int file = 0; file < 16; file++) {\n                // init square\n                int square = rank * 16 + file;\n\n                // print ranks\n                if (file == 0)\n                    System.out.printf(\" %d  \", rank + 1);\n\n                // if square is on board\n                if ((square & 0x88) == 0)\n                    System.out.printf(\"%s \",\n                            GameState.board[square] == 0 ? \".\" : unicode_pieces.get(\n                                    Color.extractColor(GameState.board[square]))[GameState.board[square] &\n                                    7]);\n            }\n\n            // print new line every time new rank is encountered\n            System.out.print(\"\\n\");\n        }\n        System.out.println();\n    }\n\n    public static void printState() {\n        System.out.println(activeColor);\n        System.out.println(pieceCount);\n        System.out.println(Arrays.toString(pieceList.get(Color.W)));\n        System.out.println(Arrays.toString(pieceList.get(Color.B)));\n        System.out.println(castleRights);\n        System.out.println(enPassant);\n    }\n\n    public static void putPiece(Color color,\n                                Piece piece,\n                                Square square, boolean listOnly) {\n        if (!listOnly) {\n            switch (piece) {\n                case PAWN -> pawnCount.merge(color, Score.get(piece.value), Integer::sum);\n                case KING -> {\n                }\n                default -> pieceCount.merge(color, Score.get(piece.value), Integer::sum);\n            }\n\n            pieceBonus.merge(color,\n                    Score.get(Psqt.table.get(color)[piece.id][Square.getRank(square)][Square.getFile(square)]),\n                    Integer::sum);\n        }\n        Square[] list = pieceList.get(color);\n\n        int startIdx = (piece.id - 1) * 10;\n        // only one slot for king\n        for (int i = 0; i < (piece == Piece.KING ? 1 : 10); i++) {\n            int nextIdx = startIdx + i;\n            if (list[nextIdx] == Square.NULL) {\n                list[nextIdx] = square;\n                return;\n            }\n        }\n    }\n\n    public static void removePiece(Color color, Piece piece, Square square, boolean listOnly) {\n        if (!listOnly) {\n            if (piece == Piece.PAWN) pawnCount.merge(color, -Score.get(piece.value), Integer::sum);\n            else pieceCount.merge(color, -Score.get(piece.value), Integer::sum);\n\n            pieceBonus.merge(color,\n                    -Score.get(Psqt.table.get(color)[piece.id][Square.getRank(square)][Square.getFile(square)]),\n                    Integer::sum);\n        }\n        pieceList.get(color)[Utils.findIndexOf(square, pieceList.get(color))] = Square.NULL;\n    }\n\n    public static void moveInPieceList(Color color, Square from, Square to) {\n        pieceList.get(color)[Utils.findIndexOf(from,\n                pieceList.get(color))] = to;\n    }\n\n    public static void moveInPieceList(Color color, Piece piece, Square from, Square to) {\n        pieceBonus.merge(color,\n                -Score.get(Psqt.table.get(color)[piece.id][Square.getRank(from)][Square.getFile(from)]),\n                Integer::sum);\n        pieceBonus.merge(color, Score.get(Psqt.table.get(color)[piece.id][Square.getRank(to)][Square.getFile(to)]),\n                Integer::sum);\n        pieceList.get(color)[Utils.findIndexOf(from,\n                pieceList.get(color))] = to;\n    }\n\n    public static int encodePrevState() {\n        return (((halfmoves << 12) | castleRights << 8) | enPassant.idx << 1) | phase.ordinal();\n    }\n\n    private static void resetState() {\n        board = new int[128];\n\n        Arrays.fill(pieceList.get(Color.W),\n                Square.NULL);\n        Arrays.fill(pieceList.get(Color.B),\n                Square.NULL);\n\n        pieceCount.put(Color.W, 0);\n        pieceCount.put(Color.B, 0);\n    }\n\n    public static void loadFen(String fen) {\n        resetState();\n\n        Map<Character, Piece> pieceMap = new HashMap<>();\n        pieceMap.put('k',\n                Piece.KING);\n        pieceMap.put('q',\n                Piece.QUEEN);\n        pieceMap.put('r',\n                Piece.ROOK);\n        pieceMap.put('n',\n                Piece.KNIGHT);\n        pieceMap.put('b',\n                Piece.BISHOP);\n        pieceMap.put('p',\n                Piece.PAWN);\n\n        Map<Character, Integer> castleMap = new HashMap<>();\n        castleMap.put('K',\n                8);\n        castleMap.put('Q',\n                4);\n        castleMap.put('k',\n                2);\n        castleMap.put('q',\n                1);\n\n        String[] fenState = fen.split(\" \");\n\n        String fenBoard = fenState[0];\n        int rank = 7, file = 0;\n\n        for (int i = 0; i < fenBoard.length(); i++) {\n            char c = fenBoard.charAt(i);\n\n            if (c == '/') {\n                file = 0;\n                rank--;\n                continue;\n            }\n\n            if (Character.isDigit(c)) {\n                file += Character.getNumericValue(c);\n                continue;\n            }\n\n            // c represents a piece\n            char type = Character.toLowerCase(c);\n            Color color = type == c ?\n                    Color.B :\n                    Color.W;\n            int idx = rank * 16 + file;\n            Piece piece = pieceMap.get(type);\n            board[idx] = color.id | piece.id;\n            putPiece(color,\n                    piece,\n                    Square.lookup.get(idx), false);\n            file++;\n        }\n\n        String fenCastle = fenState[2];\n        castleRights = 0;\n        if (!fenCastle.equals(\"-\")) {\n            for (int i = 0; i < fenCastle.length(); i++) {\n                castleRights |= castleMap.get(fenCastle.charAt(i));\n            }\n        }\n\n        activeColor = Objects.equals(fenState[1],\n                \"w\") ?\n                Color.W :\n                Color.B;\n\n        enPassant = !Objects.equals(fenState[3],\n                \"-\") ?\n                Square.valueOf(fenState[3].toUpperCase()) :\n                Square.NULL;\n\n        halfmoves = Integer.parseInt(fenState[4]);\n        zobristHash = ZobristKey.hash();\n        totalRepititions.put(zobristHash, 1);\n    }\n\n    public static boolean inCheck(Color color) {\n        Color oppColor = Color.getOppColor(color);\n        return MoveGen.isAttacked(pieceList.get(color)[50],\n                oppColor,\n                pieceList.get(oppColor)\n        );\n    }\n\n    public static boolean isCheckmate(Color color) {\n        return inCheck(color) && getValidMoves(color, false, false).size() == 0;\n    }\n\n    public static List<Integer> getValidMoves(Color color, boolean onlyCaptures, boolean onlyChecks) {\n        Square[] list = pieceList.get(color);\n\n        List<Integer> moves = new ArrayList<>();\n\n        for (int idx = 0; idx < list.length; idx++) {\n            if (list[idx] == Square.NULL) continue;\n\n            if (idx == 50) {\n                moves.addAll(MoveGen.pseudoLegalForKing(list[50], color, pieceList.get(Color.getOppColor(color))));\n            } else if (idx < 10) {\n                moves.addAll(\n                        MoveGen.pseudoLegalForPawn(list[idx], color));\n            } else {\n                moves.addAll(MoveGen.pseudoLegal(list[idx], Piece.lookup.get(\n                        (int) Math.floor((float) idx / 10) + 1\n                ), color));\n            }\n        }\n        filterOutValidMoves(moves, onlyCaptures, onlyChecks);\n        return moves;\n    }\n\n    public static void filterOutValidMoves(List<Integer> moves, boolean onlyCaptures, boolean onlyChecks) {\n        Iterator<Integer> moveIterator = moves.iterator();\n\n        while (moveIterator.hasNext()) {\n            int move = moveIterator.next();\n            Castle castle = Castle.lookup.get((move >> 14) & 15);\n            Square from = Square.lookup.get((move >> 7) & 127);\n            Square to = Square.lookup.get(move & 127);\n\n            Color color = Color.extractColor(board[from.idx]);\n            assert color != null;\n\n            Piece pieceType = Piece.extractPieceType(board[from.idx]);\n\n            boolean valid;\n            boolean capture = board[to.idx] != 0 || (pieceType == Piece.PAWN && to == enPassant);\n            boolean check = false;\n\n            Square kingPos = pieceList.get(color)[50];\n            Color oppColor = Color.getOppColor(color);\n\n            if (castle != null) {\n                if (Utils.findIndexOf(castle.rInitSquare, pieceList.get(color)) == -1) {\n                    Utils.printMove(move);\n                    printBoard();\n                }\n                board[castle.square.idx] = board[from.idx];\n                board[from.idx] = 0;\n                board[castle.rSquare.idx] = board[castle.rInitSquare.idx];\n                board[castle.rInitSquare.idx] = 0;\n\n                valid = !MoveGen.isAttacked(to,\n                        oppColor,\n                        pieceList.get(oppColor));\n                if (onlyChecks) {\n                    pieceList.get(activeColor)[50] = castle.square;\n\n                    moveInPieceList(activeColor, castle.rInitSquare, castle.rSquare);\n\n                    check = inCheck(oppColor);\n\n                    pieceList.get(activeColor)[50] = from;\n                    moveInPieceList(activeColor, castle.rSquare, castle.rInitSquare);\n                }\n\n                board[from.idx] = board[castle.square.idx];\n                board[castle.square.idx] = 0;\n                board[castle.rInitSquare.idx] = board[castle.rSquare.idx];\n                board[castle.rSquare.idx] = 0;\n            } else if (pieceType == Piece.PAWN && to == enPassant) {\n\n                Square enPassantCaptureSquare = Square.lookup.get(\n                        to.idx + (color == Color.W ? main.moveGen.Vector.DOWN.offset :\n                                main.moveGen.Vector.UP.offset)\n                );\n\n                board[to.idx] = board[from.idx];\n                board[from.idx] = 0;\n                board[enPassantCaptureSquare.idx] = 0;\n\n                valid = !inCheck(color);\n                if (onlyChecks) {\n                    moveInPieceList(color, from, to);\n                    removePiece(oppColor, Piece.PAWN, enPassantCaptureSquare, true);\n\n                    check = !inCheck(oppColor);\n\n                    moveInPieceList(color, to, from);\n                    putPiece(oppColor, Piece.PAWN, enPassantCaptureSquare, true);\n                }\n\n                board[from.idx] = color.id | Piece.PAWN.id;\n                board[to.idx] = 0;\n                board[enPassantCaptureSquare.idx] = oppColor.id | Piece.PAWN.id;\n            } else {\n\n                int capturedPiece = board[to.idx];\n                board[to.idx] = board[from.idx];\n                board[from.idx] = 0;\n\n                valid = !MoveGen.isAttacked(pieceType == Piece.KING ? to : kingPos,\n                        oppColor,\n                        pieceList.get(oppColor));\n                if (onlyChecks) {\n                    int promote = move >> 18;\n                    if (promote != 0) {\n                        board[to.idx] = color.id | promote;\n\n                        removePiece(color, Piece.PAWN, from, true);\n                        putPiece(color, Piece.extractPieceType(promote), to, true);\n                    } else moveInPieceList(color, from, to);\n                    if (capturedPiece != 0) removePiece(oppColor, Piece.extractPieceType(capturedPiece),\n                            to, true);\n\n                    check = inCheck(oppColor);\n\n                    if (promote != 0) {\n                        removePiece(color, Piece.extractPieceType(board[to.idx]), to, true);\n                        putPiece(color, Piece.PAWN, from, true);\n                    } else moveInPieceList(color, to, from);\n\n                    if (capturedPiece != 0) putPiece(oppColor, Piece.extractPieceType(capturedPiece),\n                            to, true);\n                }\n\n                board[from.idx] = color.id | pieceType.id;\n                board[to.idx] = capturedPiece;\n            }\n\n            if (!valid || ((onlyCaptures && !capture) && (onlyChecks && !check))) moveIterator.remove();\n        }\n    }\n\n    private static void checkPhase() {\n        if (pieceCount.get(Color.W) + pieceCount.get(Color.B) <= Phase.EG.limit) {\n            phase = Phase.EG;\n            recalibrateCount();\n        }\n    }\n\n    private static void recalibrateCount() {\n        pawnCount.put(Color.W, 0);\n        pawnCount.put(Color.B, 0);\n\n        pieceCount.put(Color.W, 0);\n        pieceCount.put(Color.B, 0);\n\n        // iterate over every piece type execept the king\n        for (int i = 0; i < pieceList.get(Color.W).length - 1; i++) {\n            int pieceId = (i / 10) + 1;\n            Piece piece = Piece.lookup.get(pieceId);\n            Map<Color, Integer> countMap;\n\n            if (pieceId == 1) {\n                countMap = pawnCount;\n            } else countMap = pieceCount;\n\n            if (pieceList.get(Color.W)[i] != Square.NULL) countMap.merge(Color.W, Score.get(piece.value), Integer::sum);\n            if (pieceList.get(Color.B)[i] != Square.NULL) countMap.merge(Color.B, Score.get(piece.value), Integer::sum);\n        }\n    }\n\n    public static int makeMove(Integer move) {\n        // assume to square is a valid pseudo legal move\n\n        /*\n        move is 21 bit int\n        first 7 bits refer to the \"to\" square idx\n        next 7 bits refer to the \"from\" square idx\n        next 4 bits refer to castling\n        next 3 bits refer to promotion piece type\n         */\n        Castle castle = Castle.lookup.get((move >> 14) & 15);\n        Square from = Square.lookup.get((move >> 7) & 127);\n        Square to = Square.lookup.get(move & 127);\n        int promote = move >> 18;\n\n        int capturedPiece = 0;\n        Square capturePieceSquare = null;\n\n        Color oppColor = Color.getOppColor(activeColor);\n\n        Piece pieceType = Piece.extractPieceType(board[from.idx]);\n\n        if (castle != null) {\n            board[castle.square.idx] = board[from.idx];\n            board[from.idx] = 0;\n            board[castle.rSquare.idx] = board[castle.rInitSquare.idx];\n            board[castle.rInitSquare.idx] = 0;\n\n            moveInPieceList(activeColor, Piece.KING, from, castle.square);\n            moveInPieceList(activeColor, Piece.ROOK, castle.rInitSquare, castle.rSquare);\n\n            zobristHash ^= ZobristKey.PIECES[activeColor.ordinal()][Piece.KING.id - 1][from.idx];\n            zobristHash ^= ZobristKey.PIECES[activeColor.ordinal()][Piece.ROOK.id - 1][castle.rInitSquare.idx];\n            zobristHash ^= ZobristKey.PIECES[activeColor.ordinal()][Piece.KING.id - 1][castle.square.idx];\n            zobristHash ^= ZobristKey.PIECES[activeColor.ordinal()][Piece.ROOK.id - 1][castle.rSquare.idx];\n        } else if (pieceType == Piece.PAWN && to == enPassant) {\n            Square enPassantCaptureSquare = Square.lookup.get(\n                    to.idx + (activeColor == Color.W ? main.moveGen.Vector.DOWN.offset : main.moveGen.Vector.UP.offset)\n            );\n            capturedPiece = board[enPassantCaptureSquare.idx];\n\n            board[to.idx] = board[from.idx];\n            board[from.idx] = 0;\n            board[enPassantCaptureSquare.idx] = 0;\n\n            capturePieceSquare = enPassantCaptureSquare;\n            // capture is handled later\n\n            moveInPieceList(activeColor, Piece.PAWN, from, to);\n\n            zobristHash ^= ZobristKey.PIECES[activeColor.ordinal()][Piece.PAWN.id - 1][from.idx];\n            zobristHash ^= ZobristKey.PIECES[activeColor.ordinal()][Piece.PAWN.id - 1][to.idx];\n        } else {\n            if (board[to.idx] != 0) {\n                capturedPiece = board[to.idx];\n                capturePieceSquare = to;\n            }\n\n            board[to.idx] = board[from.idx];\n            board[from.idx] = 0;\n\n            if (promote != 0) {\n                board[to.idx] = activeColor.id | promote;\n\n                removePiece(activeColor, Piece.PAWN, from, false);\n                putPiece(activeColor, Piece.extractPieceType(promote), to, false);\n\n                zobristHash ^= ZobristKey.PIECES[activeColor.ordinal()][0][from.idx];\n                zobristHash ^= ZobristKey.PIECES[activeColor.ordinal()][promote - 1][to.idx];\n            } else {\n                moveInPieceList(activeColor, pieceType, from, to);\n\n                zobristHash ^= ZobristKey.PIECES[activeColor.ordinal()][pieceType.id - 1][from.idx];\n                zobristHash ^= ZobristKey.PIECES[activeColor.ordinal()][pieceType.id - 1][to.idx];\n            }\n        }\n\n        if (capturedPiece != 0) {\n            if (Utils.findIndexOf(capturePieceSquare, pieceList.get(oppColor)) == -1) {\n                System.out.println(Arrays.toString(board));\n                GameState.printBoard();\n            }\n            removePiece(oppColor, Piece.extractPieceType(capturedPiece), capturePieceSquare, false);\n\n            zobristHash ^= ZobristKey.PIECES[oppColor.ordinal()][(capturedPiece & 7) -\n                    1][capturePieceSquare.idx];\n        }\n\n        if (enPassant != Square.NULL) zobristHash ^= ZobristKey.EN_PASSANT[enPassant.idx];\n        enPassant = Square.NULL;\n\n        if (pieceType == Piece.KING && castleRights != 0) {\n            switch (activeColor) {\n                case W -> {\n                    zobristHash ^= ZobristKey.CASTLING_RIGHTS[Color.W.ordinal()][castleRights >> 2];\n\n                    if ((castleRights & Castle.W_K.value) != 0) castleRights ^= Castle.W_K.value;\n                    if ((castleRights & Castle.W_Q.value) != 0) castleRights ^= Castle.W_Q.value;\n                }\n\n                case B -> {\n                    zobristHash ^= ZobristKey.CASTLING_RIGHTS[Color.B.ordinal()][castleRights & 3];\n\n                    if ((castleRights & Castle.B_k.value) != 0) castleRights ^= Castle.B_k.value;\n                    if ((castleRights & Castle.B_q.value) != 0) castleRights ^= Castle.B_q.value;\n                }\n            }\n\n            zobristHash ^= ZobristKey.CASTLING_RIGHTS[activeColor.ordinal()][0];\n        } else {\n            if (pieceType == Piece.PAWN && Math.abs(from.idx - to.idx) == 2 * (main.moveGen.Vector.UP.offset)) {\n                enPassant = Square.lookup.get(\n                        from.idx + (activeColor == Color.W ? main.moveGen.Vector.UP.offset : Vector.DOWN.offset));\n                zobristHash ^= ZobristKey.EN_PASSANT[enPassant.idx];\n            }\n        }\n        // checking if rooks moved or have been captured to see if I need to toggle castleRights\n        if ((castleRights & Castle.W_Q.value) != 0 &&\n                (board[Square.A1.idx] ^ (Color.W.id | Piece.ROOK.id)) != 0) {\n            zobristHash ^= ZobristKey.CASTLING_RIGHTS[Color.W.ordinal()][castleRights >> 2];\n            castleRights ^= Castle.W_Q.value;\n            zobristHash ^= ZobristKey.CASTLING_RIGHTS[Color.W.ordinal()][castleRights >> 2];\n        }\n        if ((castleRights & Castle.W_K.value) != 0 && (board[Square.H1.idx] ^ (Color.W.id | Piece.ROOK.id)) != 0) {\n            zobristHash ^= ZobristKey.CASTLING_RIGHTS[Color.W.ordinal()][castleRights >> 2];\n            castleRights ^= Castle.W_K.value;\n            zobristHash ^= ZobristKey.CASTLING_RIGHTS[Color.W.ordinal()][castleRights >> 2];\n        }\n        if ((castleRights & Castle.B_q.value) != 0 && (board[Square.A8.idx] ^ (Color.B.id | Piece.ROOK.id)) != 0) {\n            zobristHash ^= ZobristKey.CASTLING_RIGHTS[Color.B.ordinal()][castleRights & 3];\n            castleRights ^= Castle.B_q.value;\n            zobristHash ^= ZobristKey.CASTLING_RIGHTS[Color.B.ordinal()][castleRights & 3];\n        }\n        if ((castleRights & Castle.B_k.value) != 0 && (board[Square.H8.idx] ^ (Color.B.id | Piece.ROOK.id)) != 0) {\n            zobristHash ^= ZobristKey.CASTLING_RIGHTS[Color.B.ordinal()][castleRights & 3];\n            castleRights ^= Castle.B_k.value;\n            zobristHash ^= ZobristKey.CASTLING_RIGHTS[Color.B.ordinal()][castleRights & 3];\n        }\n\n        if (capturedPiece == 0 && pieceType != Piece.PAWN) halfmoves++;\n        else halfmoves = 0;\n\n        activeColor = Color.getOppColor(activeColor);\n        if (activeColor == Color.B) zobristHash ^= ZobristKey.SIDE;\n\n        totalRepititions.merge(zobristHash, 1, Integer::sum);\n\n        checkPhase();\n\n        return capturePieceSquare != null ? (capturePieceSquare.idx << 5) | capturedPiece : 0;\n    }\n\n    public static void unmakeMove(int move, int prevState, int captureDetails) {\n\n        Castle castle = Castle.lookup.get((move >> 14) & 15);\n        Square from = Square.lookup.get((move >> 7) & 127);\n        Square to = Square.lookup.get(move & 127);\n        int promote = move >> 18;\n\n        Phase prevPhase = (prevState & 1) == 0 ? Phase.MG : Phase.EG;\n        if (prevPhase != phase) recalibrateCount();\n        Square prevEnPassant = Square.lookup.get((prevState >> 1) & 127);\n        int prevCastleRights = (prevState >> 8) & 15;\n        int prevHalfmoves = prevState >> 12;\n\n        totalRepititions.merge(zobristHash, -1, Integer::sum);\n        if (totalRepititions.get(zobristHash) == 0) totalRepititions.remove(zobristHash);\n\n        if (enPassant != Square.NULL) zobristHash ^= ZobristKey.EN_PASSANT[enPassant.idx];\n        enPassant = prevEnPassant;\n        if (enPassant != Square.NULL) zobristHash ^= ZobristKey.EN_PASSANT[enPassant.idx];\n\n        if (activeColor == Color.B) zobristHash ^= ZobristKey.SIDE;\n        activeColor = Color.getOppColor(activeColor);\n\n        if (Utils.findIndexOf(to, pieceList.get(activeColor)) == -1) {\n            Utils.printMove((from.idx << 7) | to.idx);\n            printBoard();\n            printState();\n        }\n\n        zobristHash ^= ZobristKey.CASTLING_RIGHTS[Color.W.ordinal()][castleRights >> 2];\n        zobristHash ^= ZobristKey.CASTLING_RIGHTS[Color.B.ordinal()][castleRights & 3];\n        castleRights = prevCastleRights;\n        zobristHash ^= ZobristKey.CASTLING_RIGHTS[Color.W.ordinal()][castleRights >> 2];\n        zobristHash ^= ZobristKey.CASTLING_RIGHTS[Color.B.ordinal()][castleRights & 3];\n\n        halfmoves = prevHalfmoves;\n\n        Color oppColor = Color.getOppColor(activeColor);\n\n        if (castle != null) {\n            board[from.idx] = board[castle.square.idx];\n            board[castle.square.idx] = 0;\n            zobristHash ^= ZobristKey.PIECES[activeColor.ordinal()][Piece.KING.id - 1][castle.square.idx];\n            zobristHash ^= ZobristKey.PIECES[activeColor.ordinal()][Piece.KING.id - 1][from.idx];\n\n            board[castle.rInitSquare.idx] = board[castle.rSquare.idx];\n            board[castle.rSquare.idx] = 0;\n            zobristHash ^= ZobristKey.PIECES[activeColor.ordinal()][Piece.ROOK.id - 1][castle.rInitSquare.idx];\n            zobristHash ^= ZobristKey.PIECES[activeColor.ordinal()][Piece.ROOK.id - 1][castle.rSquare.idx];\n\n            moveInPieceList(activeColor, Piece.ROOK, castle.rSquare, castle.rInitSquare);\n            moveInPieceList(activeColor, Piece.KING, castle.square, from);\n            return;\n        }\n\n        if (promote != 0) {\n            zobristHash ^= ZobristKey.PIECES[activeColor.ordinal()][(board[to.idx] & 7) - 1][to.idx];\n            removePiece(activeColor, Piece.extractPieceType(board[to.idx]), to, false);\n            board[to.idx] = 0;\n\n            board[from.idx] = activeColor.id | Piece.PAWN.id;\n            zobristHash ^= ZobristKey.PIECES[activeColor.ordinal()][0][from.idx];\n            putPiece(activeColor, Piece.PAWN, from, false);\n        } else {\n            board[from.idx] = board[to.idx];\n            board[to.idx] = 0;\n            Piece pieceType = Piece.extractPieceType(board[from.idx]);\n            moveInPieceList(activeColor, pieceType, to, from);\n\n            int pieceId = board[from.idx] & 7;\n            zobristHash ^= ZobristKey.PIECES[activeColor.ordinal()][pieceId - 1][to.idx];\n            zobristHash ^= ZobristKey.PIECES[activeColor.ordinal()][pieceId - 1][from.idx];\n        }\n\n        int capturedPiece = captureDetails & 31;\n        if (capturedPiece != 0) {\n            Square capturePieceSquare = Square.lookup.get(captureDetails >> 5);\n            board[capturePieceSquare.idx] = capturedPiece;\n            putPiece(oppColor, Piece.extractPieceType(capturedPiece),\n                    capturePieceSquare, false);\n\n            zobristHash ^=\n                    ZobristKey.PIECES[oppColor.ordinal()][(capturedPiece & 7) - 1][capturePieceSquare.idx];\n        }\n    }\n\n    public static boolean isDrawByInsufficientMaterial() {\n        int wBishopCount = 0;\n        Color wBishopColor = null;\n        int bBishopCount = 0;\n        Color bBishopColor = null;\n        int wKnightCount = 0;\n        int bKnightCount = 0;\n\n        for (int i = 0; i < pieceList.get(activeColor).length; i++) {\n            int pieceId = (i / 10) + 1;\n            Piece pieceType = Piece.lookup.get(pieceId);\n\n            switch (pieceType) {\n                case BISHOP -> {\n                    if (pieceList.get(Color.W)[i] != Square.NULL) {\n                        if (bKnightCount != 0) return false;\n                        if (wBishopCount == 1) return false;\n                        wBishopCount++;\n\n                        wBishopColor = Square.getColor(pieceList.get(Color.W)[i]);\n                        if (wBishopColor == bBishopColor) return false;\n                    }\n                    if (pieceList.get(Color.B)[i] != Square.NULL) {\n                        if (wKnightCount != 0) return false;\n                        if (bBishopCount == 1) return false;\n                        bBishopCount++;\n\n                        bBishopColor = Square.getColor(pieceList.get(Color.B)[i]);\n                        if (wBishopColor == bBishopColor) return false;\n                    }\n                }\n\n                case KNIGHT -> {\n                    if (pieceList.get(Color.W)[i] != Square.NULL) {\n                        wKnightCount++;\n                    }\n                    if (pieceList.get(Color.B)[i] != Square.NULL) {\n                        bKnightCount++;\n                    }\n                    if (wKnightCount + bKnightCount == 2) return false;\n                }\n\n                case KING -> {\n                }\n\n                default -> {\n                    if (pieceList.get(Color.W)[i] != Square.NULL ||\n                            pieceList.get(Color.B)[i] != Square.NULL) return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    public static boolean isDrawByRepitition(long mostRecentHash) {\n        return totalRepititions.get(mostRecentHash) == 3;\n    }\n\n    public static boolean isDrawByMoveRule() {\n        int MAX_MOVES = 100;\n        return halfmoves == MAX_MOVES;\n    }\n\n    public static boolean isDraw() {\n        return isDrawByMoveRule() || isDrawByRepitition(GameState.zobristHash) || isDrawByInsufficientMaterial();\n    }\n\n    public static int countNumOfPositions(int depth, boolean print) {\n\n        if (depth == 0) return 1;\n        int count = 0;\n        List<Integer> moves = getValidMoves(activeColor, false, false);\n        for (Integer move : moves) {\n            int moveCount = 0;\n            int prevState = ((halfmoves << 11) | castleRights << 7) | enPassant.idx;\n            int captureDetails = makeMove(move);\n\n            moveCount += countNumOfPositions(depth - 1);\n            count += moveCount;\n            if (print) {\n                System.out.printf(\"%s%s: %d; depth: %d %n\", Square.lookup.get((move >> 7) & 127),\n                        Square.lookup.get(move & 127),\n                        moveCount, depth);\n            }\n            unmakeMove(move, prevState, captureDetails);\n        }\n        return count;\n    }\n\n    public static int countNumOfPositions(int depth) {\n        if (depth == 0) return 1;\n        int count = 0;\n        List<Integer> moves = getValidMoves(activeColor, false, false);\n        for (Integer move : moves) {\n            int prevState = ((halfmoves << 11) | castleRights << 7) | enPassant.idx;\n            int captureDetails = makeMove(move);\n\n            count += countNumOfPositions(depth - 1);\n\n            unmakeMove(move, prevState, captureDetails);\n        }\n        return count;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/GameState.java b/src/main/GameState.java
--- a/src/main/GameState.java	
+++ b/src/main/GameState.java	
@@ -315,6 +315,7 @@
         halfmoves = Integer.parseInt(fenState[4]);
         zobristHash = ZobristKey.hash();
         totalRepititions.put(zobristHash, 1);
+        checkPhase();
     }
 
     public static boolean inCheck(Color color) {
@@ -466,7 +467,7 @@
     }
 
     private static void checkPhase() {
-        if (pieceCount.get(Color.W) + pieceCount.get(Color.B) <= Phase.EG.limit) {
+        if (phase == Phase.MG && pieceCount.get(Color.W) + pieceCount.get(Color.B) <= Phase.EG.limit) {
             phase = Phase.EG;
             recalibrateCount();
         }
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"c480323b-7fea-48df-b943-12edce4efed6\" name=\"Changes\" comment=\"\">\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/main/moveGen/GameState.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/moveGen/GameState.java\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/main/moveGen/MoveGen.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/moveGen/MoveGen.java\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/main/moveGen/UnmakeDetails.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/moveGen/UnmakeDetails.java\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/main/moveGen/ZobristKey.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/moveGen/ZobristKey.java\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/test/moveGen/GameStateTest.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/test/moveGen/GameStateTest.java\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"FileTemplateManagerImpl\">\n    <option name=\"RECENT_TEMPLATES\">\n      <list>\n        <option value=\"Interface\" />\n        <option value=\"Enum\" />\n        <option value=\"Class\" />\n      </list>\n    </option>\n  </component>\n  <component name=\"FormatOnSaveOptions\">\n    <option name=\"myRunOnSave\" value=\"true\" />\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n  </component>\n  <component name=\"MarkdownSettingsMigration\">\n    <option name=\"stateVersion\" value=\"1\" />\n  </component>\n  <component name=\"ProjectId\" id=\"2HVUopz1sKMTPfB7yDHdb0GVZ6W\" />\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\">{\n  &quot;keyToString&quot;: {\n    &quot;Downloaded.Files.Path.Enabled&quot;: &quot;false&quot;,\n    &quot;Repository.Attach.Annotations&quot;: &quot;false&quot;,\n    &quot;Repository.Attach.JavaDocs&quot;: &quot;false&quot;,\n    &quot;Repository.Attach.Sources&quot;: &quot;false&quot;,\n    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\n    &quot;SHARE_PROJECT_CONFIGURATION_FILES&quot;: &quot;true&quot;,\n    &quot;last_opened_file_path&quot;: &quot;/home/alex/JavaProjects/chess-api/src/main/utils/Utils.java&quot;,\n    &quot;settings.editor.selected.configurable&quot;: &quot;preferences.sourceCode.Java&quot;\n  }\n}</component>\n  <component name=\"RecentsManager\">\n    <key name=\"MoveFile.RECENT_KEYS\">\n      <recent name=\"$PROJECT_DIR$/src/test/moveGen\" />\n      <recent name=\"$PROJECT_DIR$/src\" />\n    </key>\n  </component>\n  <component name=\"RunManager\" selected=\"JUnit.GameStateTest$unmakeDetails$undoZobristHash.promotion\">\n    <configuration name=\"GameStateTest$makeMove$zobristHash.worksForPromotion\" type=\"JUnit\" factoryName=\"JUnit\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"chess-api\" />\n      <extension name=\"coverage\">\n        <pattern>\n          <option name=\"PATTERN\" value=\"test.moveGen.*\" />\n          <option name=\"ENABLED\" value=\"true\" />\n        </pattern>\n      </extension>\n      <option name=\"PACKAGE_NAME\" value=\"test.moveGen.GameStateTest.makeMove\" />\n      <option name=\"MAIN_CLASS_NAME\" value=\"test.moveGen.GameStateTest$makeMove$zobristHash\" />\n      <option name=\"METHOD_NAME\" value=\"worksForPromotion\" />\n      <option name=\"TEST_OBJECT\" value=\"method\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"GameStateTest$unmakeDetails$undoZobristHash$castleMoves\" type=\"JUnit\" factoryName=\"JUnit\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"chess-api\" />\n      <extension name=\"coverage\">\n        <pattern>\n          <option name=\"PATTERN\" value=\"test.moveGen.*\" />\n          <option name=\"ENABLED\" value=\"true\" />\n        </pattern>\n      </extension>\n      <option name=\"PACKAGE_NAME\" value=\"test.moveGen.GameStateTest.unmakeDetails.undoZobristHash\" />\n      <option name=\"MAIN_CLASS_NAME\" value=\"test.moveGen.GameStateTest$unmakeDetails$undoZobristHash$castleMoves\" />\n      <option name=\"TEST_OBJECT\" value=\"class\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"GameStateTest$unmakeDetails$undoZobristHash.promotion\" type=\"JUnit\" factoryName=\"JUnit\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"chess-api\" />\n      <extension name=\"coverage\">\n        <pattern>\n          <option name=\"PATTERN\" value=\"test.moveGen.*\" />\n          <option name=\"ENABLED\" value=\"true\" />\n        </pattern>\n      </extension>\n      <option name=\"PACKAGE_NAME\" value=\"test.moveGen.GameStateTest.unmakeDetails\" />\n      <option name=\"MAIN_CLASS_NAME\" value=\"test.moveGen.GameStateTest$unmakeDetails$undoZobristHash\" />\n      <option name=\"METHOD_NAME\" value=\"promotion\" />\n      <option name=\"TEST_OBJECT\" value=\"method\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"GameStateTest$unmakeDetails$undoZobristHash.worksForCaptures\" type=\"JUnit\" factoryName=\"JUnit\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"chess-api\" />\n      <extension name=\"coverage\">\n        <pattern>\n          <option name=\"PATTERN\" value=\"test.moveGen.*\" />\n          <option name=\"ENABLED\" value=\"true\" />\n        </pattern>\n      </extension>\n      <option name=\"PACKAGE_NAME\" value=\"test.moveGen.GameStateTest.unmakeDetails\" />\n      <option name=\"MAIN_CLASS_NAME\" value=\"test.moveGen.GameStateTest$unmakeDetails$undoZobristHash\" />\n      <option name=\"METHOD_NAME\" value=\"worksForCaptures\" />\n      <option name=\"TEST_OBJECT\" value=\"method\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"GameStateTest\" type=\"JUnit\" factoryName=\"JUnit\" temporary=\"true\" nameIsGenerated=\"true\">\n      <module name=\"chess-api\" />\n      <extension name=\"coverage\">\n        <pattern>\n          <option name=\"PATTERN\" value=\"test.moveGen.*\" />\n          <option name=\"ENABLED\" value=\"true\" />\n        </pattern>\n      </extension>\n      <option name=\"PACKAGE_NAME\" value=\"test.moveGen\" />\n      <option name=\"MAIN_CLASS_NAME\" value=\"test.moveGen.GameStateTest\" />\n      <option name=\"TEST_OBJECT\" value=\"class\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <recent_temporary>\n      <list>\n        <item itemvalue=\"JUnit.GameStateTest$unmakeDetails$undoZobristHash.promotion\" />\n        <item itemvalue=\"JUnit.GameStateTest$unmakeDetails$undoZobristHash$castleMoves\" />\n        <item itemvalue=\"JUnit.GameStateTest$unmakeDetails$undoZobristHash.worksForCaptures\" />\n        <item itemvalue=\"JUnit.GameStateTest\" />\n        <item itemvalue=\"JUnit.GameStateTest$makeMove$zobristHash.worksForPromotion\" />\n      </list>\n    </recent_temporary>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"c480323b-7fea-48df-b943-12edce4efed6\" name=\"Changes\" comment=\"\" />\n      <created>1668369921862</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1668369921862</updated>\n    </task>\n    <servers />\n  </component>\n  <component name=\"Vcs.Log.Tabs.Properties\">\n    <option name=\"TAB_STATES\">\n      <map>\n        <entry key=\"MAIN\">\n          <value>\n            <State />\n          </value>\n        </entry>\n      </map>\n    </option>\n  </component>\n  <component name=\"XDebuggerManager\">\n    <watches-manager>\n      <configuration name=\"JUnit\">\n        <watch expression=\"zobristHash\" language=\"JAVA\" />\n        <watch expression=\"GameState.zobristHash\" language=\"JAVA\" />\n      </configuration>\n    </watches-manager>\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	
+++ b/.idea/workspace.xml	
@@ -1,13 +1,12 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
+  <component name="AutoImportSettings">
+    <option name="autoReloadType" value="SELECTIVE" />
+  </component>
   <component name="ChangeListManager">
     <list default="true" id="c480323b-7fea-48df-b943-12edce4efed6" name="Changes" comment="">
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/moveGen/GameState.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/moveGen/GameState.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/moveGen/MoveGen.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/moveGen/MoveGen.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/moveGen/UnmakeDetails.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/moveGen/UnmakeDetails.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/moveGen/ZobristKey.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/moveGen/ZobristKey.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/test/moveGen/GameStateTest.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/test/moveGen/GameStateTest.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/GameState.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/GameState.java" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -27,6 +26,11 @@
     <option name="myRunOnSave" value="true" />
   </component>
   <component name="Git.Settings">
+    <option name="RECENT_BRANCH_BY_REPOSITORY">
+      <map>
+        <entry key="$PROJECT_DIR$" value="658b37505f5ce6a091b7b166cec71be7fec6042d" />
+      </map>
+    </option>
     <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
   </component>
   <component name="MarkdownSettingsMigration">
@@ -40,6 +44,7 @@
   </component>
   <component name="PropertiesComponent">{
   &quot;keyToString&quot;: {
+    &quot;ASKED_ADD_EXTERNAL_FILES&quot;: &quot;true&quot;,
     &quot;Downloaded.Files.Path.Enabled&quot;: &quot;false&quot;,
     &quot;Repository.Attach.Annotations&quot;: &quot;false&quot;,
     &quot;Repository.Attach.JavaDocs&quot;: &quot;false&quot;,
@@ -48,101 +53,103 @@
     &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
     &quot;SHARE_PROJECT_CONFIGURATION_FILES&quot;: &quot;true&quot;,
     &quot;last_opened_file_path&quot;: &quot;/home/alex/JavaProjects/chess-api/src/main/utils/Utils.java&quot;,
-    &quot;settings.editor.selected.configurable&quot;: &quot;preferences.sourceCode.Java&quot;
+    &quot;settings.editor.selected.configurable&quot;: &quot;preferences.pluginManager&quot;
   }
 }</component>
   <component name="RecentsManager">
     <key name="MoveFile.RECENT_KEYS">
+      <recent name="$PROJECT_DIR$/src/main/types" />
       <recent name="$PROJECT_DIR$/src/test/moveGen" />
       <recent name="$PROJECT_DIR$/src" />
     </key>
   </component>
-  <component name="RunManager" selected="JUnit.GameStateTest$unmakeDetails$undoZobristHash.promotion">
-    <configuration name="GameStateTest$makeMove$zobristHash.worksForPromotion" type="JUnit" factoryName="JUnit" temporary="true" nameIsGenerated="true">
+  <component name="RunManager" selected="JUnit.MoveEvalTest$engineDebug.seriesDebug">
+    <configuration name="MoveEvalTest$engineDebug.seriesDebug" type="JUnit" factoryName="JUnit" temporary="true" nameIsGenerated="true">
       <module name="chess-api" />
       <extension name="coverage">
         <pattern>
-          <option name="PATTERN" value="test.moveGen.*" />
+          <option name="PATTERN" value="test.moveEval.*" />
           <option name="ENABLED" value="true" />
         </pattern>
       </extension>
-      <option name="PACKAGE_NAME" value="test.moveGen.GameStateTest.makeMove" />
-      <option name="MAIN_CLASS_NAME" value="test.moveGen.GameStateTest$makeMove$zobristHash" />
-      <option name="METHOD_NAME" value="worksForPromotion" />
+      <option name="PACKAGE_NAME" value="test.moveEval.MoveEvalTest" />
+      <option name="MAIN_CLASS_NAME" value="test.moveEval.MoveEvalTest$engineDebug" />
+      <option name="METHOD_NAME" value="seriesDebug" />
       <option name="TEST_OBJECT" value="method" />
       <method v="2">
         <option name="Make" enabled="true" />
       </method>
     </configuration>
-    <configuration name="GameStateTest$unmakeDetails$undoZobristHash$castleMoves" type="JUnit" factoryName="JUnit" temporary="true" nameIsGenerated="true">
+    <configuration name="MoveEvalTest$tactics.pos1" type="JUnit" factoryName="JUnit" temporary="true" nameIsGenerated="true">
       <module name="chess-api" />
       <extension name="coverage">
         <pattern>
-          <option name="PATTERN" value="test.moveGen.*" />
+          <option name="PATTERN" value="test.moveEval.*" />
           <option name="ENABLED" value="true" />
         </pattern>
       </extension>
-      <option name="PACKAGE_NAME" value="test.moveGen.GameStateTest.unmakeDetails.undoZobristHash" />
-      <option name="MAIN_CLASS_NAME" value="test.moveGen.GameStateTest$unmakeDetails$undoZobristHash$castleMoves" />
-      <option name="TEST_OBJECT" value="class" />
+      <option name="PACKAGE_NAME" value="test.moveEval.MoveEvalTest" />
+      <option name="MAIN_CLASS_NAME" value="test.moveEval.MoveEvalTest$tactics" />
+      <option name="METHOD_NAME" value="pos1" />
+      <option name="TEST_OBJECT" value="method" />
       <method v="2">
         <option name="Make" enabled="true" />
       </method>
     </configuration>
-    <configuration name="GameStateTest$unmakeDetails$undoZobristHash.promotion" type="JUnit" factoryName="JUnit" temporary="true" nameIsGenerated="true">
+    <configuration name="MoveEvalTest$tactics.pos2" type="JUnit" factoryName="JUnit" temporary="true" nameIsGenerated="true">
       <module name="chess-api" />
       <extension name="coverage">
         <pattern>
-          <option name="PATTERN" value="test.moveGen.*" />
+          <option name="PATTERN" value="test.moveEval.*" />
           <option name="ENABLED" value="true" />
         </pattern>
       </extension>
-      <option name="PACKAGE_NAME" value="test.moveGen.GameStateTest.unmakeDetails" />
-      <option name="MAIN_CLASS_NAME" value="test.moveGen.GameStateTest$unmakeDetails$undoZobristHash" />
-      <option name="METHOD_NAME" value="promotion" />
+      <option name="PACKAGE_NAME" value="test.moveEval.MoveEvalTest" />
+      <option name="MAIN_CLASS_NAME" value="test.moveEval.MoveEvalTest$tactics" />
+      <option name="METHOD_NAME" value="pos2" />
       <option name="TEST_OBJECT" value="method" />
       <method v="2">
         <option name="Make" enabled="true" />
       </method>
     </configuration>
-    <configuration name="GameStateTest$unmakeDetails$undoZobristHash.worksForCaptures" type="JUnit" factoryName="JUnit" temporary="true" nameIsGenerated="true">
+    <configuration name="MoveEvalTest" type="JUnit" factoryName="JUnit" temporary="true" nameIsGenerated="true">
       <module name="chess-api" />
       <extension name="coverage">
         <pattern>
-          <option name="PATTERN" value="test.moveGen.*" />
+          <option name="PATTERN" value="test.moveEval.*" />
           <option name="ENABLED" value="true" />
         </pattern>
       </extension>
-      <option name="PACKAGE_NAME" value="test.moveGen.GameStateTest.unmakeDetails" />
-      <option name="MAIN_CLASS_NAME" value="test.moveGen.GameStateTest$unmakeDetails$undoZobristHash" />
-      <option name="METHOD_NAME" value="worksForCaptures" />
-      <option name="TEST_OBJECT" value="method" />
+      <option name="PACKAGE_NAME" value="test.moveEval" />
+      <option name="MAIN_CLASS_NAME" value="test.moveEval.MoveEvalTest" />
+      <option name="TEST_OBJECT" value="class" />
       <method v="2">
         <option name="Make" enabled="true" />
       </method>
     </configuration>
-    <configuration name="GameStateTest" type="JUnit" factoryName="JUnit" temporary="true" nameIsGenerated="true">
+    <configuration name="MoveEvalTest.givesSameMoveOnRepeatCalls" type="JUnit" factoryName="JUnit" temporary="true" nameIsGenerated="true">
       <module name="chess-api" />
       <extension name="coverage">
         <pattern>
-          <option name="PATTERN" value="test.moveGen.*" />
+          <option name="PATTERN" value="test.moveEval.*" />
           <option name="ENABLED" value="true" />
         </pattern>
       </extension>
-      <option name="PACKAGE_NAME" value="test.moveGen" />
-      <option name="MAIN_CLASS_NAME" value="test.moveGen.GameStateTest" />
-      <option name="TEST_OBJECT" value="class" />
+      <option name="PACKAGE_NAME" value="test.moveEval" />
+      <option name="MAIN_CLASS_NAME" value="test.moveEval.MoveEvalTest" />
+      <option name="METHOD_NAME" value="givesSameMoveOnRepeatCalls" />
+      <option name="TEST_OBJECT" value="method" />
       <method v="2">
         <option name="Make" enabled="true" />
       </method>
     </configuration>
     <recent_temporary>
       <list>
-        <item itemvalue="JUnit.GameStateTest$unmakeDetails$undoZobristHash.promotion" />
-        <item itemvalue="JUnit.GameStateTest$unmakeDetails$undoZobristHash$castleMoves" />
-        <item itemvalue="JUnit.GameStateTest$unmakeDetails$undoZobristHash.worksForCaptures" />
-        <item itemvalue="JUnit.GameStateTest" />
-        <item itemvalue="JUnit.GameStateTest$makeMove$zobristHash.worksForPromotion" />
+        <item itemvalue="JUnit.MoveEvalTest$engineDebug.seriesDebug" />
+        <item itemvalue="JUnit.MoveEvalTest.givesSameMoveOnRepeatCalls" />
+        <item itemvalue="JUnit.MoveEvalTest" />
+        <item itemvalue="JUnit.MoveEvalTest$tactics.pos2" />
+        <item itemvalue="JUnit.MoveEvalTest$tactics.pos1" />
       </list>
     </recent_temporary>
   </component>
@@ -169,11 +176,29 @@
     </option>
   </component>
   <component name="XDebuggerManager">
+    <breakpoint-manager>
+      <breakpoints>
+        <breakpoint enabled="true" type="java-exception">
+          <properties class="java.lang.AssertionError" package="java.lang" />
+          <option name="timeStamp" value="1" />
+        </breakpoint>
+      </breakpoints>
+    </breakpoint-manager>
     <watches-manager>
       <configuration name="JUnit">
-        <watch expression="zobristHash" language="JAVA" />
-        <watch expression="GameState.zobristHash" language="JAVA" />
+        <watch expression="Utils.convertMove(forcingMoves.get(i))" language="JAVA" />
+        <watch expression="Utils.convertMove(legalMoves.get(i))" language="JAVA" />
+        <watch expression="Utils.convertMove(move)" language="JAVA" />
+        <watch expression="GameState.activeColor" language="JAVA" />
       </configuration>
     </watches-manager>
   </component>
+  <component name="com.intellij.coverage.CoverageDataManagerImpl">
+    <SUITE FILE_PATH="coverage/chess_api$MoveEvalTest_tactics_mateIn4.ic" NAME="MoveEvalTest$tactics.mateIn4 Coverage Results" MODIFIED="1671302492195" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="idea" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false">
+      <FILTER>test.moveEval.*</FILTER>
+    </SUITE>
+    <SUITE FILE_PATH="coverage/chess_api$GameStateTest_moveGenTest_debuggingPosition.ic" NAME="GameStateTest$moveGenTest.debuggingPosition Coverage Results" MODIFIED="1669535701280" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="idea" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false">
+      <FILTER>test.moveGen.*</FILTER>
+    </SUITE>
+  </component>
 </project>
\ No newline at end of file
